import { Result } from "nevereverthrow";
import { z } from "zod";
import { Pattern } from "fast-glob";
import { cancel, confirm, groupMultiselect, isCancel, log, multiselect, password, select, spinner, text } from "@clack/prompts";
import pc from "picocolors";
import { Agent } from "package-manager-detector";

//#region src/utils/types.d.ts
type LooseAutocomplete<T> = T | (string & {});
type Prettify<T> = { [K in keyof T]: T[K] } & {};
declare const brand: unique symbol;
type Brand<B extends string> = {
  [brand]: B;
};
/** Allows you to create a branded type.
 *
 * ## Usage
 * ```ts
 * type Milliseconds = Brand<number, 'milliseconds'>;
 * ```
 */
type Branded<T, B extends string> = T & Brand<B>;
/**
 * An absolute path to a file. Can be used to immediately read the file.
 */
type AbsolutePath = Branded<string, 'absolutePath'>;
/**
 * A path relative to the parent item.
 */
type ItemRelativePath = Branded<string, 'itemRelativePath'>;
//#endregion
//#region src/utils/warnings.d.ts
/**
 * Base warning class. All warnings should extend this class.
 */
declare class Warning {
  readonly message: string;
  constructor(message: string);
}
/**
 * Type for a warning handler function.
 */
type WarningHandler = (warning: Warning) => void;
/**
 * Warning when a language cannot be found to resolve dependencies for a file.
 */
declare class LanguageNotFoundWarning extends Warning {
  readonly path: string;
  constructor(options: {
    path: string;
  });
}
/**
 * Warning when an import is skipped because it's not a valid package name or path alias.
 */
declare class InvalidImportWarning extends Warning {
  readonly specifier: string;
  readonly fileName: string;
  constructor(options: {
    specifier: string;
    fileName: string;
  });
}
/**
 * Warning when a dynamic import cannot be resolved due to unresolvable syntax.
 */
declare class UnresolvableDynamicImportWarning extends Warning {
  readonly specifier: string;
  readonly fileName: string;
  constructor(options: {
    specifier: string;
    fileName: string;
  });
}
/**
 * Warning when a glob pattern doesn't match any files.
 */
declare class GlobPatternNoMatchWarning extends Warning {
  readonly itemName: string;
  readonly pattern: string;
  constructor(options: {
    itemName: string;
    pattern: string;
  });
}
/**
 * Creates a warning handler that uses the onwarn callback if provided, otherwise uses the default logger.
 */
declare function createWarningHandler(onwarn?: Config['onwarn']): WarningHandler;
//#endregion
//#region src/langs/types.d.ts
type ResolveDependenciesOptions = {
  fileName: AbsolutePath;
  cwd: AbsolutePath;
  excludeDeps: string[];
  warn: WarningHandler;
};
type InstallDependenciesOptions = {
  cwd: AbsolutePath;
};
type TransformImportsOptions = {
  cwd: AbsolutePath;
  /** The path of the file that the imports will be transformed for. */
  targetPath: string;
  item: string;
  file: {
    type: RegistryItemType;
    path: ItemRelativePath;
  };
  getItemPath(opts: {
    item: string;
    file: {
      type: RegistryItemType;
    };
  }): {
    /** The resolved path of the dependency. */
    path: string;
    /** The alias of the dependency. */
    alias?: string;
  };
};
type ImportTransform = {
  /** The pattern to match the import. */
  pattern: string | RegExp;
  /** The replacement for the import. */
  replacement: string;
};
type ResolveDependenciesResult = {
  localDependencies: LocalDependency[];
  dependencies: RemoteDependency[];
  devDependencies: RemoteDependency[];
};
interface Language {
  /** The name of the language. */
  name: string;
  /** Determines whether or not the language can resolve dependencies for the given file. */
  canResolveDependencies(fileName: string): boolean;
  resolveDependencies(code: string, opts: ResolveDependenciesOptions): Promise<ResolveDependenciesResult> | ResolveDependenciesResult;
  /** Returns an object where the key is the import to be transformed and the value is the transformed import. */
  transformImports(code: string, _imports_: UnresolvedImport[], opts: TransformImportsOptions): Promise<string>;
  /** Determines whether or not the language can install dependencies for the given ecosystem. */
  canInstallDependencies(ecosystem: Ecosystem): boolean;
  /** Gets the install command to add the given dependencies to the project. */
  installDependencies(dependencies: {
    dependencies: RemoteDependency[];
    devDependencies: RemoteDependency[];
  }, opts: InstallDependenciesOptions): Promise<void> | void;
}
//#endregion
//#region src/langs/css.d.ts
type CssOptions = {
  /**
   * Whether to allow tailwind directives to be parsed as imports.
   * @default true
   */
  allowTailwindDirectives: boolean;
};
/**
 * Detect dependencies in `.css`, `.scss`, and `.sass` files.
 * @example
 * ```ts
 * import { defineConfig } from "jsrepo";
 * import { css } from "jsrepo/langs";
 *
 * export default defineConfig({
 *  // ...
 *  languages: [css()],
 * });
 * ```
 *
 * @param options - The options for the language plugin.
 */
declare function css({
  allowTailwindDirectives
}?: Partial<CssOptions>): Language;
//#endregion
//#region src/langs/html.d.ts
type HtmlOptions = {
  scripts: {
    /**
     * Whether to resolve the src attribute of a script tag as a dependency.
     * @default true
     */
    resolveSrc: boolean;
    /**
     * Whether to resolve dependencies within the code of a script tag.
     * @default true
     */
    resolveCode: boolean;
  };
  /**
   * Whether to resolve the href attribute of a link tag as a dependency.
   * @default true
   */
  resolveLinks: boolean;
};
/**
 * Detect dependencies in `.html` files by parsing script src attributes and code and link href attributes.
 * @example
 * ```ts
 * import { defineConfig } from "jsrepo";
 * import { html } from "jsrepo/langs";
 *
 * export default defineConfig({
 *  // ...
 *  languages: [html()],
 * });
 * ```
 *
 * @param options - The options for the language plugin.
 */
declare function html({
  scripts,
  resolveLinks
}?: Partial<HtmlOptions>): Language;
//#endregion
//#region src/langs/js.d.ts
type JsOptions = {};
/**
 * Despite the name this is for javascript and typescript.
 */
declare function js(_options?: JsOptions): Language;
/**
 * Resolves dependencies for javascript and typescript.
 * @param code
 * @param opts
 */
declare function resolveImports(imports: string[], opts: ResolveDependenciesOptions): Promise<{
  localDependencies: LocalDependency[];
  dependencies: RemoteDependency[];
  devDependencies: RemoteDependency[];
}>;
declare function getImports(code: string, {
  fileName,
  warn
}: {
  fileName: ResolveDependenciesOptions['fileName'];
  warn: ResolveDependenciesOptions['warn'];
}): Promise<string[]>;
declare function transformImports(code: string, _imports_: UnresolvedImport[], opts: TransformImportsOptions): Promise<string>;
declare function installDependencies(dependencies: {
  dependencies: RemoteDependency[];
  devDependencies: RemoteDependency[];
}, {
  cwd
}: InstallDependenciesOptions): Promise<void>;
//#endregion
//#region src/langs/svelte.d.ts
type SvelteOptions = {};
/**
 * Svelte language support.
 *
 * @remarks
 * Requires `svelte` to be installed in your project.
 */
declare function svelte(_options?: SvelteOptions): Language;
//#endregion
//#region src/langs/vue.d.ts
type VueOptions = {};
/**
 * Vue language support.
 *
 * @remarks
 * Requires `vue` to be installed in your project.
 */
declare function vue(_options?: VueOptions): Language;
//#endregion
//#region src/langs/index.d.ts
declare const DEFAULT_LANGS: Language[];
//#endregion
//#region src/utils/errors.d.ts
type CLIError = JsrepoError | NoPackageJsonFoundError | ConfigNotFoundError | InvalidRegistryError | RegistryItemNotFoundError | ManifestFetchError | RegistryItemFetchError | RegistryFileFetchError | RegistryNotProvidedError | MultipleRegistriesError | AlreadyInitializedError | FailedToLoadConfigError | ConfigNotFoundError | InvalidOptionsError | NoRegistriesError | NoOutputsError | NoPathProvidedError | NoListedItemsError | DuplicateItemNameError | SelfReferenceError | NoFilesError | IllegalItemNameError | InvalidRegistryDependencyError | DuplicateFileReferenceError | FileNotFoundError | ImportedFileNotResolvedError | InvalidPluginError | InvalidKeyTypeError | ConfigObjectNotFoundError | CouldNotFindJsrepoImportError | ZodError | InvalidJSONError | NoProviderFoundError | MissingPeerDependencyError | InvalidRegistryNameError | InvalidRegistryVersionError | Unreachable;
declare class JsrepoError extends Error {
  private readonly suggestion;
  private readonly docsLink?;
  constructor(message: string, options: {
    suggestion: string;
    docsLink?: string;
  });
  toString(): string;
}
declare class NoPackageJsonFoundError extends JsrepoError {
  constructor();
}
declare class InvalidRegistryError extends JsrepoError {
  constructor(registry: string);
}
declare class RegistryItemNotFoundError extends JsrepoError {
  constructor(itemName: string, registry?: string);
}
declare class ProviderFetchError extends JsrepoError {
  readonly resourcePath: string;
  readonly originalMessage: string;
  constructor(message: string, resourcePath: string);
}
declare class ManifestFetchError extends JsrepoError {
  constructor(error: unknown);
}
declare class RegistryItemFetchError extends JsrepoError {
  constructor(error: unknown, options: {
    registry: string;
    item: string;
  });
}
declare class RegistryFileFetchError extends JsrepoError {
  constructor(message: string, options: {
    registry: string;
    item: string;
    resourcePath: string | undefined;
  });
}
declare class RegistryNotProvidedError extends JsrepoError {
  constructor();
}
declare class MultipleRegistriesError extends JsrepoError {
  constructor(itemName: string, registries: string[]);
}
declare class AlreadyInitializedError extends JsrepoError {
  constructor();
}
declare class FailedToLoadConfigError extends JsrepoError {
  constructor(cause: unknown);
}
declare class ConfigNotFoundError extends JsrepoError {
  constructor(path: string);
}
declare class InvalidOptionsError extends JsrepoError {
  constructor(error: z.ZodError);
}
declare class NoRegistriesError extends JsrepoError {
  constructor();
}
declare class NoPathProvidedError extends JsrepoError {
  constructor({
    item,
    type
  }: {
    item: string;
    type: string;
  });
}
declare class BuildError extends JsrepoError {
  readonly registryName: string;
  constructor(message: string, options: {
    registryName: string;
    suggestion: string;
    docsLink?: string;
  });
}
declare class ModuleNotFoundError extends JsrepoError {
  constructor(mod: string, {
    fileName
  }: {
    fileName: string;
  });
}
declare class NoOutputsError extends BuildError {
  constructor({
    registryName
  }: {
    registryName: string;
  });
}
declare class NoListedItemsError extends BuildError {
  constructor({
    registryName
  }: {
    registryName: string;
  });
}
declare class DuplicateItemNameError extends BuildError {
  constructor({
    name,
    registryName
  }: {
    name: string;
    registryName: string;
  });
}
declare class SelfReferenceError extends BuildError {
  constructor({
    name,
    registryName
  }: {
    name: string;
    registryName: string;
  });
}
declare class NoFilesError extends BuildError {
  constructor({
    name,
    registryName
  }: {
    name: string;
    registryName: string;
  });
}
declare class IllegalItemNameError extends BuildError {
  constructor({
    name,
    registryName
  }: {
    name: string;
    registryName: string;
  });
}
declare class InvalidRegistryDependencyError extends BuildError {
  constructor({
    dependency,
    item,
    registryName
  }: {
    dependency: string;
    item: string;
    registryName: string;
  });
}
declare class InvalidDependencyError extends BuildError {
  constructor({
    dependency,
    registryName,
    itemName
  }: {
    dependency: string;
    registryName: string;
    itemName: string;
  });
}
declare class DuplicateFileReferenceError extends BuildError {
  constructor({
    path,
    parent,
    duplicateParent,
    registryName
  }: {
    path: string;
    parent: {
      name: string;
      type: RegistryItemType;
    };
    duplicateParent: {
      name: string;
      type: RegistryItemType;
    };
    registryName: string;
  });
}
declare class FileNotFoundError extends BuildError {
  constructor({
    path,
    parent,
    registryName
  }: {
    path: string;
    parent: {
      name: string;
      type: RegistryItemType;
    };
    registryName: string;
  });
}
declare class ImportedFileNotResolvedError extends BuildError {
  constructor({
    referencedFile,
    fileName,
    item,
    registryName
  }: {
    referencedFile: string;
    fileName: string;
    item: string;
    registryName: string;
  });
}
declare class InvalidPluginError extends JsrepoError {
  constructor(plugin: string);
}
declare class InvalidKeyTypeError extends JsrepoError {
  constructor({
    key,
    type
  }: {
    key: string;
    type: 'object' | 'array';
  });
}
declare class ConfigObjectNotFoundError extends JsrepoError {
  constructor();
}
declare class CouldNotFindJsrepoImportError extends JsrepoError {
  constructor();
}
declare class ZodError extends JsrepoError {
  readonly zodError: z.ZodError;
  constructor(error: z.ZodError);
}
declare class InvalidJSONError extends JsrepoError {
  constructor(error: unknown);
}
declare class GlobError extends BuildError {
  constructor(error: unknown, pattern: Pattern, registryName: string);
}
declare class NoProviderFoundError extends JsrepoError {
  constructor(provider: string);
}
declare class NoItemsToUpdateError extends JsrepoError {
  constructor();
}
declare class MissingPeerDependencyError extends JsrepoError {
  constructor(packageName: string, feature: string);
}
declare class InvalidRegistryNameError extends JsrepoError {
  constructor(registryName: string);
}
declare class InvalidRegistryVersionError extends JsrepoError {
  constructor(registryVersion: string | undefined, registryName: string);
}
/**
 * This error is thrown when a code path should be unreachable.
 */
declare class Unreachable extends JsrepoError {
  constructor();
}
//#endregion
//#region src/outputs/distributed.d.ts
type DistributedOutputOptions = {
  /** The directory to output the files to */
  dir: string;
  /** Whether or not to format the output. @default false */
  format?: boolean;
};
/**
 * Use this output type when you are going to serve your registry as a static asset.
 *
 * ```ts
 * import { distributed } from "jsrepo/outputs";
 *
 * export default defineConfig({
 *   // ...
 *   outputs: [distributed({ dir: "./public/r" })]
 * });
 * ```
 *
 * This will create a file structure like:
 * ```plaintext
 * üìÅ public/r
 * ‚îú‚îÄ‚îÄ registry.json
 * ‚îú‚îÄ‚îÄ button.json
 * ‚îî‚îÄ‚îÄ math.json
 * ```
 * @param options
 * @returns
 */
declare function distributed({
  dir,
  format
}: DistributedOutputOptions): Output;
declare const DistributedOutputManifestFileSchema: z.ZodObject<{
  path: z.ZodPipe<z.ZodString, z.ZodTransform<ItemRelativePath, string>>;
  type: z.ZodString;
  role: z.ZodUnion<readonly [z.ZodUnion<z.ZodLiteral<"file" | "example" | "doc" | "test">[]>, z.ZodUndefined]>;
  target: z.ZodUnion<readonly [z.ZodString, z.ZodUndefined]>;
  registryDependencies: z.ZodUnion<readonly [z.ZodArray<z.ZodString>, z.ZodUndefined]>;
  dependencies: z.ZodUnion<readonly [z.ZodArray<z.ZodObject<{
    ecosystem: z.ZodString;
    name: z.ZodString;
    version: z.ZodOptional<z.ZodString>;
  }, z.core.$strip>>, z.ZodUndefined]>;
  devDependencies: z.ZodUnion<readonly [z.ZodArray<z.ZodObject<{
    ecosystem: z.ZodString;
    name: z.ZodString;
    version: z.ZodOptional<z.ZodString>;
  }, z.core.$strip>>, z.ZodUndefined]>;
}, z.core.$strip>;
type DistributedOutputManifestFile = z.infer<typeof DistributedOutputManifestFileSchema>;
declare const DistributedOutputManifestSchema: z.ZodObject<{
  name: z.ZodString;
  description: z.ZodOptional<z.ZodString>;
  version: z.ZodOptional<z.ZodString>;
  homepage: z.ZodOptional<z.ZodString>;
  tags: z.ZodOptional<z.ZodArray<z.ZodString>>;
  repository: z.ZodOptional<z.ZodString>;
  bugs: z.ZodOptional<z.ZodString>;
  authors: z.ZodOptional<z.ZodArray<z.ZodString>>;
  meta: z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodString>>;
  access: z.ZodOptional<z.ZodEnum<{
    public: "public";
    private: "private";
    marketplace: "marketplace";
  }>>;
  type: z.ZodDefault<z.ZodUnion<readonly [z.ZodLiteral<"distributed">, z.ZodUndefined]>>;
  plugins: z.ZodUnion<readonly [z.ZodObject<{
    languages: z.ZodOptional<z.ZodArray<z.ZodObject<{
      package: z.ZodString;
      version: z.ZodOptional<z.ZodString>;
      optional: z.ZodOptional<z.ZodBoolean>;
    }, z.core.$strip>>>;
    providers: z.ZodOptional<z.ZodArray<z.ZodObject<{
      package: z.ZodString;
      version: z.ZodOptional<z.ZodString>;
      optional: z.ZodOptional<z.ZodBoolean>;
    }, z.core.$strip>>>;
    transforms: z.ZodOptional<z.ZodArray<z.ZodObject<{
      package: z.ZodString;
      version: z.ZodOptional<z.ZodString>;
      optional: z.ZodOptional<z.ZodBoolean>;
    }, z.core.$strip>>>;
  }, z.core.$strip>, z.ZodUndefined]>;
  items: z.ZodArray<z.ZodObject<{
    name: z.ZodString;
    title: z.ZodUnion<readonly [z.ZodString, z.ZodUndefined]>;
    description: z.ZodUnion<readonly [z.ZodString, z.ZodUndefined]>;
    type: z.ZodString;
    registryDependencies: z.ZodUnion<readonly [z.ZodArray<z.ZodString>, z.ZodUndefined]>;
    add: z.ZodUnion<readonly [z.ZodEnum<{
      "optionally-on-init": "optionally-on-init";
      "on-init": "on-init";
      "when-needed": "when-needed";
      "when-added": "when-added";
    }>, z.ZodUndefined]>;
    dependencies: z.ZodUnion<readonly [z.ZodArray<z.ZodUnion<readonly [z.ZodObject<{
      ecosystem: z.ZodString;
      name: z.ZodString;
      version: z.ZodOptional<z.ZodString>;
    }, z.core.$strip>, z.ZodString]>>, z.ZodUndefined]>;
    devDependencies: z.ZodUnion<readonly [z.ZodArray<z.ZodUnion<readonly [z.ZodObject<{
      ecosystem: z.ZodString;
      name: z.ZodString;
      version: z.ZodOptional<z.ZodString>;
    }, z.core.$strip>, z.ZodString]>>, z.ZodUndefined]>;
    envVars: z.ZodUnion<readonly [z.ZodRecord<z.ZodString, z.ZodString>, z.ZodUndefined]>;
    files: z.ZodDefault<z.ZodUnion<readonly [z.ZodArray<z.ZodObject<{
      path: z.ZodPipe<z.ZodString, z.ZodTransform<ItemRelativePath, string>>;
      type: z.ZodString;
      role: z.ZodUnion<readonly [z.ZodUnion<z.ZodLiteral<"file" | "example" | "doc" | "test">[]>, z.ZodUndefined]>;
      target: z.ZodUnion<readonly [z.ZodString, z.ZodUndefined]>;
      registryDependencies: z.ZodUnion<readonly [z.ZodArray<z.ZodString>, z.ZodUndefined]>;
      dependencies: z.ZodUnion<readonly [z.ZodArray<z.ZodObject<{
        ecosystem: z.ZodString;
        name: z.ZodString;
        version: z.ZodOptional<z.ZodString>;
      }, z.core.$strip>>, z.ZodUndefined]>;
      devDependencies: z.ZodUnion<readonly [z.ZodArray<z.ZodObject<{
        ecosystem: z.ZodString;
        name: z.ZodString;
        version: z.ZodOptional<z.ZodString>;
      }, z.core.$strip>>, z.ZodUndefined]>;
    }, z.core.$strip>>, z.ZodUndefined]>>;
    categories: z.ZodUnion<readonly [z.ZodArray<z.ZodString>, z.ZodUndefined]>;
    meta: z.ZodUnion<readonly [z.ZodRecord<z.ZodString, z.ZodString>, z.ZodUndefined]>;
  }, z.core.$strip>>;
  defaultPaths: z.ZodUnion<readonly [z.ZodRecord<z.ZodString, z.ZodString>, z.ZodUndefined]>;
}, z.core.$strip>;
type DistributedOutputManifest = z.infer<typeof DistributedOutputManifestSchema>;
declare const DistributedOutputItemSchema: z.ZodObject<{
  $schema: z.ZodOptional<z.ZodString>;
  name: z.ZodString;
  title: z.ZodUnion<readonly [z.ZodString, z.ZodUndefined]>;
  description: z.ZodUnion<readonly [z.ZodString, z.ZodUndefined]>;
  type: z.ZodString;
  registryDependencies: z.ZodUnion<readonly [z.ZodArray<z.ZodString>, z.ZodUndefined]>;
  add: z.ZodUnion<readonly [z.ZodEnum<{
    "optionally-on-init": "optionally-on-init";
    "on-init": "on-init";
    "when-needed": "when-needed";
    "when-added": "when-added";
  }>, z.ZodUndefined]>;
  dependencies: z.ZodUnion<readonly [z.ZodArray<z.ZodUnion<readonly [z.ZodObject<{
    ecosystem: z.ZodString;
    name: z.ZodString;
    version: z.ZodOptional<z.ZodString>;
  }, z.core.$strip>, z.ZodString]>>, z.ZodUndefined]>;
  devDependencies: z.ZodUnion<readonly [z.ZodArray<z.ZodUnion<readonly [z.ZodObject<{
    ecosystem: z.ZodString;
    name: z.ZodString;
    version: z.ZodOptional<z.ZodString>;
  }, z.core.$strip>, z.ZodString]>>, z.ZodUndefined]>;
  envVars: z.ZodUnion<readonly [z.ZodRecord<z.ZodString, z.ZodString>, z.ZodUndefined]>;
  files: z.ZodDefault<z.ZodUnion<readonly [z.ZodArray<z.ZodObject<{
    path: z.ZodPipe<z.ZodString, z.ZodTransform<ItemRelativePath, string>>;
    content: z.ZodString;
    type: z.ZodString;
    role: z.ZodUnion<readonly [z.ZodUnion<z.ZodLiteral<"file" | "example" | "doc" | "test">[]>, z.ZodUndefined]>;
    _imports_: z.ZodUnion<readonly [z.ZodArray<z.ZodObject<{
      import: z.ZodString;
      item: z.ZodString;
      file: z.ZodObject<{
        type: z.ZodString;
        path: z.ZodPipe<z.ZodString, z.ZodTransform<ItemRelativePath, string>>;
      }, z.core.$strip>;
      meta: z.ZodRecord<z.ZodString, z.ZodUnknown>;
    }, z.core.$strip>>, z.ZodUndefined]>;
    target: z.ZodUnion<readonly [z.ZodString, z.ZodUndefined]>;
    registryDependencies: z.ZodUnion<readonly [z.ZodArray<z.ZodString>, z.ZodUndefined]>;
    dependencies: z.ZodUnion<readonly [z.ZodArray<z.ZodObject<{
      ecosystem: z.ZodString;
      name: z.ZodString;
      version: z.ZodOptional<z.ZodString>;
    }, z.core.$strip>>, z.ZodUndefined]>;
    devDependencies: z.ZodUnion<readonly [z.ZodArray<z.ZodObject<{
      ecosystem: z.ZodString;
      name: z.ZodString;
      version: z.ZodOptional<z.ZodString>;
    }, z.core.$strip>>, z.ZodUndefined]>;
  }, z.core.$strip>>, z.ZodUndefined]>>;
  categories: z.ZodUnion<readonly [z.ZodArray<z.ZodString>, z.ZodUndefined]>;
  meta: z.ZodUnion<readonly [z.ZodRecord<z.ZodString, z.ZodString>, z.ZodUndefined]>;
}, z.core.$strip>;
type DistributedOutputItem = z.infer<typeof DistributedOutputItemSchema>;
//#endregion
//#region src/outputs/repository.d.ts
type RepositoryOutputOptions = {
  /** Whether or not to format the output. @default false */
  format?: boolean;
};
/**
 * Use this output type when you are serving your registry from a repository.
 *
 * ```ts
 * import { repository } from "jsrepo/outputs";
 *
 * export default defineConfig({
 *   // ...
 *   outputs: [repository()]
 * });
 * ```
 *
 * This will create a manifest file at the root of your repository like:
 * ```plaintext
 * üìÅ .
 * ‚îî‚îÄ‚îÄ registry.json
 * ```
 * @param options
 * @returns
 */
declare function repository({
  format
}?: RepositoryOutputOptions): Output;
declare const RepositoryOutputFileSchema: z.ZodObject<{
  path: z.ZodPipe<z.ZodString, z.ZodTransform<ItemRelativePath, string>>;
  type: z.ZodString;
  role: z.ZodUnion<readonly [z.ZodUnion<z.ZodLiteral<"file" | "example" | "doc" | "test">[]>, z.ZodUndefined]>;
  relativePath: z.ZodPipe<z.ZodString, z.ZodTransform<never, string>>;
  _imports_: z.ZodArray<z.ZodObject<{
    import: z.ZodString;
    item: z.ZodString;
    file: z.ZodObject<{
      type: z.ZodString;
      path: z.ZodPipe<z.ZodString, z.ZodTransform<ItemRelativePath, string>>;
    }, z.core.$strip>;
    meta: z.ZodRecord<z.ZodString, z.ZodUnknown>;
  }, z.core.$strip>>;
  target: z.ZodUnion<readonly [z.ZodString, z.ZodUndefined]>;
  registryDependencies: z.ZodUnion<readonly [z.ZodArray<z.ZodString>, z.ZodUndefined]>;
  dependencies: z.ZodUnion<readonly [z.ZodArray<z.ZodObject<{
    ecosystem: z.ZodString;
    name: z.ZodString;
    version: z.ZodOptional<z.ZodString>;
  }, z.core.$strip>>, z.ZodUndefined]>;
  devDependencies: z.ZodUnion<readonly [z.ZodArray<z.ZodObject<{
    ecosystem: z.ZodString;
    name: z.ZodString;
    version: z.ZodOptional<z.ZodString>;
  }, z.core.$strip>>, z.ZodUndefined]>;
}, z.core.$strip>;
type RepositoryOutputFile = z.infer<typeof RepositoryOutputFileSchema>;
declare const RepositoryOutputManifestSchema: z.ZodObject<{
  name: z.ZodString;
  description: z.ZodOptional<z.ZodString>;
  version: z.ZodOptional<z.ZodString>;
  homepage: z.ZodOptional<z.ZodString>;
  tags: z.ZodOptional<z.ZodArray<z.ZodString>>;
  repository: z.ZodOptional<z.ZodString>;
  bugs: z.ZodOptional<z.ZodString>;
  authors: z.ZodOptional<z.ZodArray<z.ZodString>>;
  meta: z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodString>>;
  access: z.ZodOptional<z.ZodEnum<{
    public: "public";
    private: "private";
    marketplace: "marketplace";
  }>>;
  type: z.ZodLiteral<"repository">;
  plugins: z.ZodUnion<readonly [z.ZodObject<{
    languages: z.ZodOptional<z.ZodArray<z.ZodObject<{
      package: z.ZodString;
      version: z.ZodOptional<z.ZodString>;
      optional: z.ZodOptional<z.ZodBoolean>;
    }, z.core.$strip>>>;
    providers: z.ZodOptional<z.ZodArray<z.ZodObject<{
      package: z.ZodString;
      version: z.ZodOptional<z.ZodString>;
      optional: z.ZodOptional<z.ZodBoolean>;
    }, z.core.$strip>>>;
    transforms: z.ZodOptional<z.ZodArray<z.ZodObject<{
      package: z.ZodString;
      version: z.ZodOptional<z.ZodString>;
      optional: z.ZodOptional<z.ZodBoolean>;
    }, z.core.$strip>>>;
  }, z.core.$strip>, z.ZodUndefined]>;
  items: z.ZodArray<z.ZodObject<{
    name: z.ZodString;
    title: z.ZodUnion<readonly [z.ZodString, z.ZodUndefined]>;
    description: z.ZodUnion<readonly [z.ZodString, z.ZodUndefined]>;
    type: z.ZodString;
    registryDependencies: z.ZodUnion<readonly [z.ZodArray<z.ZodString>, z.ZodUndefined]>;
    add: z.ZodUnion<readonly [z.ZodEnum<{
      "optionally-on-init": "optionally-on-init";
      "on-init": "on-init";
      "when-needed": "when-needed";
      "when-added": "when-added";
    }>, z.ZodUndefined]>;
    files: z.ZodDefault<z.ZodUnion<readonly [z.ZodArray<z.ZodObject<{
      path: z.ZodPipe<z.ZodString, z.ZodTransform<ItemRelativePath, string>>;
      type: z.ZodString;
      role: z.ZodUnion<readonly [z.ZodUnion<z.ZodLiteral<"file" | "example" | "doc" | "test">[]>, z.ZodUndefined]>;
      relativePath: z.ZodPipe<z.ZodString, z.ZodTransform<never, string>>;
      _imports_: z.ZodArray<z.ZodObject<{
        import: z.ZodString;
        item: z.ZodString;
        file: z.ZodObject<{
          type: z.ZodString;
          path: z.ZodPipe<z.ZodString, z.ZodTransform<ItemRelativePath, string>>;
        }, z.core.$strip>;
        meta: z.ZodRecord<z.ZodString, z.ZodUnknown>;
      }, z.core.$strip>>;
      target: z.ZodUnion<readonly [z.ZodString, z.ZodUndefined]>;
      registryDependencies: z.ZodUnion<readonly [z.ZodArray<z.ZodString>, z.ZodUndefined]>;
      dependencies: z.ZodUnion<readonly [z.ZodArray<z.ZodObject<{
        ecosystem: z.ZodString;
        name: z.ZodString;
        version: z.ZodOptional<z.ZodString>;
      }, z.core.$strip>>, z.ZodUndefined]>;
      devDependencies: z.ZodUnion<readonly [z.ZodArray<z.ZodObject<{
        ecosystem: z.ZodString;
        name: z.ZodString;
        version: z.ZodOptional<z.ZodString>;
      }, z.core.$strip>>, z.ZodUndefined]>;
    }, z.core.$strip>>, z.ZodUndefined]>>;
    dependencies: z.ZodUnion<readonly [z.ZodArray<z.ZodUnion<readonly [z.ZodObject<{
      ecosystem: z.ZodString;
      name: z.ZodString;
      version: z.ZodOptional<z.ZodString>;
    }, z.core.$strip>, z.ZodString]>>, z.ZodUndefined]>;
    devDependencies: z.ZodUnion<readonly [z.ZodArray<z.ZodUnion<readonly [z.ZodObject<{
      ecosystem: z.ZodString;
      name: z.ZodString;
      version: z.ZodOptional<z.ZodString>;
    }, z.core.$strip>, z.ZodString]>>, z.ZodUndefined]>;
    envVars: z.ZodUnion<readonly [z.ZodRecord<z.ZodString, z.ZodString>, z.ZodUndefined]>;
    categories: z.ZodUnion<readonly [z.ZodArray<z.ZodString>, z.ZodUndefined]>;
    meta: z.ZodUnion<readonly [z.ZodRecord<z.ZodString, z.ZodString>, z.ZodUndefined]>;
  }, z.core.$strip>>;
  defaultPaths: z.ZodUnion<readonly [z.ZodRecord<z.ZodString, z.ZodString>, z.ZodUndefined]>;
}, z.core.$strip>;
type RepositoryOutputManifest = z.infer<typeof RepositoryOutputManifestSchema>;
//#endregion
//#region src/outputs/index.d.ts
declare const ManifestSchema: z.ZodDiscriminatedUnion<[z.ZodObject<{
  name: z.ZodString;
  description: z.ZodOptional<z.ZodString>;
  version: z.ZodOptional<z.ZodString>;
  homepage: z.ZodOptional<z.ZodString>;
  tags: z.ZodOptional<z.ZodArray<z.ZodString>>;
  repository: z.ZodOptional<z.ZodString>;
  bugs: z.ZodOptional<z.ZodString>;
  authors: z.ZodOptional<z.ZodArray<z.ZodString>>;
  meta: z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodString>>;
  access: z.ZodOptional<z.ZodEnum<{
    public: "public";
    private: "private";
    marketplace: "marketplace";
  }>>;
  type: z.ZodDefault<z.ZodUnion<readonly [z.ZodLiteral<"distributed">, z.ZodUndefined]>>;
  plugins: z.ZodUnion<readonly [z.ZodObject<{
    languages: z.ZodOptional<z.ZodArray<z.ZodObject<{
      package: z.ZodString;
      version: z.ZodOptional<z.ZodString>;
      optional: z.ZodOptional<z.ZodBoolean>;
    }, z.core.$strip>>>;
    providers: z.ZodOptional<z.ZodArray<z.ZodObject<{
      package: z.ZodString;
      version: z.ZodOptional<z.ZodString>;
      optional: z.ZodOptional<z.ZodBoolean>;
    }, z.core.$strip>>>;
    transforms: z.ZodOptional<z.ZodArray<z.ZodObject<{
      package: z.ZodString;
      version: z.ZodOptional<z.ZodString>;
      optional: z.ZodOptional<z.ZodBoolean>;
    }, z.core.$strip>>>;
  }, z.core.$strip>, z.ZodUndefined]>;
  items: z.ZodArray<z.ZodObject<{
    name: z.ZodString;
    title: z.ZodUnion<readonly [z.ZodString, z.ZodUndefined]>;
    description: z.ZodUnion<readonly [z.ZodString, z.ZodUndefined]>;
    type: z.ZodString;
    registryDependencies: z.ZodUnion<readonly [z.ZodArray<z.ZodString>, z.ZodUndefined]>;
    add: z.ZodUnion<readonly [z.ZodEnum<{
      "optionally-on-init": "optionally-on-init";
      "on-init": "on-init";
      "when-needed": "when-needed";
      "when-added": "when-added";
    }>, z.ZodUndefined]>;
    dependencies: z.ZodUnion<readonly [z.ZodArray<z.ZodUnion<readonly [z.ZodObject<{
      ecosystem: z.ZodString;
      name: z.ZodString;
      version: z.ZodOptional<z.ZodString>;
    }, z.core.$strip>, z.ZodString]>>, z.ZodUndefined]>;
    devDependencies: z.ZodUnion<readonly [z.ZodArray<z.ZodUnion<readonly [z.ZodObject<{
      ecosystem: z.ZodString;
      name: z.ZodString;
      version: z.ZodOptional<z.ZodString>;
    }, z.core.$strip>, z.ZodString]>>, z.ZodUndefined]>;
    envVars: z.ZodUnion<readonly [z.ZodRecord<z.ZodString, z.ZodString>, z.ZodUndefined]>;
    files: z.ZodDefault<z.ZodUnion<readonly [z.ZodArray<z.ZodObject<{
      path: z.ZodPipe<z.ZodString, z.ZodTransform<ItemRelativePath, string>>;
      type: z.ZodString;
      role: z.ZodUnion<readonly [z.ZodUnion<z.ZodLiteral<"file" | "example" | "doc" | "test">[]>, z.ZodUndefined]>;
      target: z.ZodUnion<readonly [z.ZodString, z.ZodUndefined]>;
      registryDependencies: z.ZodUnion<readonly [z.ZodArray<z.ZodString>, z.ZodUndefined]>;
      dependencies: z.ZodUnion<readonly [z.ZodArray<z.ZodObject<{
        ecosystem: z.ZodString;
        name: z.ZodString;
        version: z.ZodOptional<z.ZodString>;
      }, z.core.$strip>>, z.ZodUndefined]>;
      devDependencies: z.ZodUnion<readonly [z.ZodArray<z.ZodObject<{
        ecosystem: z.ZodString;
        name: z.ZodString;
        version: z.ZodOptional<z.ZodString>;
      }, z.core.$strip>>, z.ZodUndefined]>;
    }, z.core.$strip>>, z.ZodUndefined]>>;
    categories: z.ZodUnion<readonly [z.ZodArray<z.ZodString>, z.ZodUndefined]>;
    meta: z.ZodUnion<readonly [z.ZodRecord<z.ZodString, z.ZodString>, z.ZodUndefined]>;
  }, z.core.$strip>>;
  defaultPaths: z.ZodUnion<readonly [z.ZodRecord<z.ZodString, z.ZodString>, z.ZodUndefined]>;
}, z.core.$strip>, z.ZodObject<{
  name: z.ZodString;
  description: z.ZodOptional<z.ZodString>;
  version: z.ZodOptional<z.ZodString>;
  homepage: z.ZodOptional<z.ZodString>;
  tags: z.ZodOptional<z.ZodArray<z.ZodString>>;
  repository: z.ZodOptional<z.ZodString>;
  bugs: z.ZodOptional<z.ZodString>;
  authors: z.ZodOptional<z.ZodArray<z.ZodString>>;
  meta: z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodString>>;
  access: z.ZodOptional<z.ZodEnum<{
    public: "public";
    private: "private";
    marketplace: "marketplace";
  }>>;
  type: z.ZodLiteral<"repository">;
  plugins: z.ZodUnion<readonly [z.ZodObject<{
    languages: z.ZodOptional<z.ZodArray<z.ZodObject<{
      package: z.ZodString;
      version: z.ZodOptional<z.ZodString>;
      optional: z.ZodOptional<z.ZodBoolean>;
    }, z.core.$strip>>>;
    providers: z.ZodOptional<z.ZodArray<z.ZodObject<{
      package: z.ZodString;
      version: z.ZodOptional<z.ZodString>;
      optional: z.ZodOptional<z.ZodBoolean>;
    }, z.core.$strip>>>;
    transforms: z.ZodOptional<z.ZodArray<z.ZodObject<{
      package: z.ZodString;
      version: z.ZodOptional<z.ZodString>;
      optional: z.ZodOptional<z.ZodBoolean>;
    }, z.core.$strip>>>;
  }, z.core.$strip>, z.ZodUndefined]>;
  items: z.ZodArray<z.ZodObject<{
    name: z.ZodString;
    title: z.ZodUnion<readonly [z.ZodString, z.ZodUndefined]>;
    description: z.ZodUnion<readonly [z.ZodString, z.ZodUndefined]>;
    type: z.ZodString;
    registryDependencies: z.ZodUnion<readonly [z.ZodArray<z.ZodString>, z.ZodUndefined]>;
    add: z.ZodUnion<readonly [z.ZodEnum<{
      "optionally-on-init": "optionally-on-init";
      "on-init": "on-init";
      "when-needed": "when-needed";
      "when-added": "when-added";
    }>, z.ZodUndefined]>;
    files: z.ZodDefault<z.ZodUnion<readonly [z.ZodArray<z.ZodObject<{
      path: z.ZodPipe<z.ZodString, z.ZodTransform<ItemRelativePath, string>>;
      type: z.ZodString;
      role: z.ZodUnion<readonly [z.ZodUnion<z.ZodLiteral<"file" | "example" | "doc" | "test">[]>, z.ZodUndefined]>;
      relativePath: z.ZodPipe<z.ZodString, z.ZodTransform<never, string>>;
      _imports_: z.ZodArray<z.ZodObject<{
        import: z.ZodString;
        item: z.ZodString;
        file: z.ZodObject<{
          type: z.ZodString;
          path: z.ZodPipe<z.ZodString, z.ZodTransform<ItemRelativePath, string>>;
        }, z.core.$strip>;
        meta: z.ZodRecord<z.ZodString, z.ZodUnknown>;
      }, z.core.$strip>>;
      target: z.ZodUnion<readonly [z.ZodString, z.ZodUndefined]>;
      registryDependencies: z.ZodUnion<readonly [z.ZodArray<z.ZodString>, z.ZodUndefined]>;
      dependencies: z.ZodUnion<readonly [z.ZodArray<z.ZodObject<{
        ecosystem: z.ZodString;
        name: z.ZodString;
        version: z.ZodOptional<z.ZodString>;
      }, z.core.$strip>>, z.ZodUndefined]>;
      devDependencies: z.ZodUnion<readonly [z.ZodArray<z.ZodObject<{
        ecosystem: z.ZodString;
        name: z.ZodString;
        version: z.ZodOptional<z.ZodString>;
      }, z.core.$strip>>, z.ZodUndefined]>;
    }, z.core.$strip>>, z.ZodUndefined]>>;
    dependencies: z.ZodUnion<readonly [z.ZodArray<z.ZodUnion<readonly [z.ZodObject<{
      ecosystem: z.ZodString;
      name: z.ZodString;
      version: z.ZodOptional<z.ZodString>;
    }, z.core.$strip>, z.ZodString]>>, z.ZodUndefined]>;
    devDependencies: z.ZodUnion<readonly [z.ZodArray<z.ZodUnion<readonly [z.ZodObject<{
      ecosystem: z.ZodString;
      name: z.ZodString;
      version: z.ZodOptional<z.ZodString>;
    }, z.core.$strip>, z.ZodString]>>, z.ZodUndefined]>;
    envVars: z.ZodUnion<readonly [z.ZodRecord<z.ZodString, z.ZodString>, z.ZodUndefined]>;
    categories: z.ZodUnion<readonly [z.ZodArray<z.ZodString>, z.ZodUndefined]>;
    meta: z.ZodUnion<readonly [z.ZodRecord<z.ZodString, z.ZodString>, z.ZodUndefined]>;
  }, z.core.$strip>>;
  defaultPaths: z.ZodUnion<readonly [z.ZodRecord<z.ZodString, z.ZodString>, z.ZodUndefined]>;
}, z.core.$strip>], "type">;
type Manifest = z.infer<typeof ManifestSchema>;
//#endregion
//#region src/providers/types.d.ts
type FetchOptions = {
  token: string | undefined;
  fetch?: typeof fetch;
};
type CreateOptions = {
  token: string | undefined;
  fetch?: typeof fetch;
  cwd: AbsolutePath;
};
type Prompts = {
  multiselect: typeof multiselect;
  select: typeof select;
  text: typeof text;
  log: typeof log;
  password: typeof password;
  spinner: typeof spinner;
  confirm: typeof confirm;
  groupMultiselect: typeof groupMultiselect;
  isCancel: typeof isCancel;
  cancel: typeof cancel;
  color: typeof pc;
};
type GetToken = (options: {
  /**
   * Prompts to use to authenticate the user.
   */
  p: Prompts;
}) => Promise<string>;
type GetTokenWithRegistry = (options: {
  /**
   * The registry the user is attempting to authenticate to.
   */
  registry: string;
  /**
   * Prompts to use to authenticate the user.
   */
  p: Prompts;
}) => Promise<string>;
interface ProviderFactory {
  /** Must be unique used for identifying the provider. */
  name: string;
  /** Determines whether or not the provider can handle the given URL. */
  matches(url: string): boolean;
  create(url: string, createOpts: CreateOptions): Promise<Provider>;
  /**
   * Configures how jsrepo will authenticate the user for this provider.
   *
   * Leaving this blank if your provider doesn't require authentication.
   */
  auth?: {
    /**
     * Configures how jsrepo will store the token for this provider.
     *
     * - "provider" - Tokens are stored at the provider level and used by all registries for this provider.
     * - "registry" - Tokens are stored at the registry level and used only by that registry.
     */
    tokenStoredFor: 'provider';
    /**
     * Name of the environment variable to fallback on if no token is provided.
     */
    envVar?: string;
    /**
     * Authenticate the user for this provider by returning a token.
     *
     * If left blank jsrepo will prompt the user for a token.
     *
     * @param options
     * @returns
     */
    getToken?: GetToken;
  } | {
    /**
     * Configures how jsrepo will store the token for this provider.
     *
     * - "provider" - Tokens are stored at the provider level and used by all registries for this provider.
     * - "registry" - Tokens are stored at the registry level and used only by that registry.
     */
    tokenStoredFor: 'registry';
    /**
     * Authenticate the user for this provider/registry by returning a token.
     *
     * If left blank jsrepo will prompt the user for a token.
     *
     * @param options
     * @returns
     */
    getToken?: GetTokenWithRegistry;
  };
}
interface Provider {
  fetch(resourcePath: string, fetchOpts: FetchOptions): Promise<string>;
}
//#endregion
//#region src/providers/azure.d.ts
type AzureOptions = {
  /** If you are self hosting Azure DevOps and you want azure/ to default to your base url instead of https://dev.azure.com */
  baseUrl?: string;
};
/**
 * The built in Azure DevOps provider.
 * @param options
 * @returns
 *
 * @urlFormat
 * ```
 * 'azure/<org>/<project>/<repo>'
 * 'azure/<org>/<project>/<repo>/heads/<ref>'
 * 'azure/<org>/<project>/<repo>/tags/<ref>'
 * ```
 *
 * @example
 * ```ts
 * import { defineConfig } from "jsrepo/config";
 * import { azure } from "jsrepo/providers";
 *
 * export default defineConfig({
 * 	providers: [azure()],
 * });
 * ```
 */
declare function azure(options?: AzureOptions): ProviderFactory;
//#endregion
//#region src/providers/bitbucket.d.ts
type BitBucketOptions = {
  /** If you are self hosting Bitbucket and you want bitbucket/ to default to your base url instead of https://bitbucket.org */
  baseUrl?: string;
};
/**
 * The built in Bitbucket provider.
 * @param options
 * @returns
 *
 * @urlFormat
 * ```
 * 'https://bitbucket.org/<owner>/<repo>'
 * 'bitbucket/<owner>/<repo>'
 * 'bitbucket/<owner>/<repo>/src/<ref>'
 * ```
 *
 * @example
 * ```ts
 * import { defineConfig } from "jsrepo/config";
 * import { bitbucket } from "jsrepo/providers";
 *
 * export default defineConfig({
 * 	providers: [bitbucket()],
 * });
 * ```
 */
declare function bitbucket(options?: BitBucketOptions): ProviderFactory;
//#endregion
//#region src/providers/fs.d.ts
type FsOptions = {
  /** In case you want all your registry paths to be relative to a base directory. */
  baseDir?: string;
};
/**
 * The built in File System provider. Allows you to run registries locally using the file system.
 * @param options
 * @returns
 *
 * @urlFormat
 * ```
 * 'fs://<path>'
 * 'fs://../relative/path' // relative paths
 * 'fs://users/john' // absolute path
 * ```
 *
 * @example
 * ```ts
 * import { defineConfig } from "jsrepo/config";
 * import { fs } from "jsrepo/providers";
 *
 * export default defineConfig({
 * 	providers: [fs()],
 * });
 * ```
 */
declare function _fs(options?: FsOptions): ProviderFactory;
//#endregion
//#region src/providers/github.d.ts
type GitHubOptions = {
  /** If you are self hosting GitHub and you want github/ to default to your base url instead of https://github.com */
  baseUrl?: string;
};
/**
 * The built in GitHub provider.
 * @param options
 * @returns
 *
 * @urlFormat
 * ```
 * 'https://github.com/<owner>/<repo>'
 * 'github/<owner>/<repo>'
 * 'github/<owner>/<repo>/tree/<ref>'
 * ```
 *
 * @example
 * ```ts
 * import { defineConfig } from "jsrepo/config";
 * import { github } from "jsrepo/providers";
 *
 * export default defineConfig({
 * 	providers: [github()],
 * });
 * ```
 */
declare function github(options?: GitHubOptions): ProviderFactory;
//#endregion
//#region src/providers/gitlab.d.ts
type GitLabOptions = {
  /** If you are self hosting GitLab and you want gitlab/ to default to your base url instead of https://gitlab.com */
  baseUrl?: string;
};
/**
 * The built in GitLab provider.
 * @param options
 * @returns
 *
 * @urlFormat
 * ```
 * 'https://gitlab.com/<owner>/<repo>'
 * 'gitlab/<owner>/<repo>'
 * 'gitlab/<owner>/<repo>/-/tree/<ref>'
 * 'gitlab/<owner>/[...group]/<repo>'
 * ```
 *
 * @example
 * ```ts
 * import { defineConfig } from "jsrepo/config";
 * import { gitlab } from "jsrepo/providers";
 *
 * export default defineConfig({
 * 	providers: [gitlab()],
 * });
 * ```
 */
declare function gitlab(options?: GitLabOptions): ProviderFactory;
//#endregion
//#region src/providers/http.d.ts
type HttpOptions = ({
  baseUrl?: never;
  /**
   * Override the auth header for all sites.
   *
   * @default
   * ```ts
   * (token) => ({ Authorization: `Bearer ${token}` })
   * ```
   */
  authHeader?: (token: string) => Record<string, string>;
} | {
  /** The base url for your site. */
  baseUrl: string;
  /** The auth header for your site. */
  authHeader?: (token: string) => Record<string, string>;
}) & {
  /**
   * Additional headers to add to the request. The authHeader function result will override these headers.
   */
  headers?: Record<string, string>;
};
/**
 * The built in http provider. When using this provider you should place it at the end of the providers array otherwise it will match all urls.
 * @param options
 * @returns
 *
 * @urlFormat
 * ```
 * 'https://<domain>/<path to registry.json>'
 * ```
 *
 * @note
 * If you aren't providing a base url then you should place this provider at the end of the providers array. Otherwise it will match all urls.
 *
 * @example
 * ```ts
 * import { defineConfig } from "jsrepo/config";
 * import { http } from "jsrepo/providers";
 *
 * export default defineConfig({
 * 	providers: [http()],
 * });
 * ```
 * @example
 * ### Custom Provider
 * ```ts
 * import { defineConfig } from "jsrepo/config";
 * import { http } from "jsrepo/providers";
 *
 * export default defineConfig({
 * 	providers: [http({
 *      baseUrl: "https://privateui.com",
 *      authHeader: (token) => ({
 *          "Token": token
 *      })
 *  })],
 * });
 * ```
 *
 * Now when you use `https://privateui.com` it will use the auth header you provided.
 */
declare function http(options?: HttpOptions): ProviderFactory;
//#endregion
//#region src/providers/jsrepo.d.ts
type JsrepoOptions = {
  baseUrl?: string;
};
/**
 * The built in jsrepo provider.
 * @param options
 * @returns
 *
 * @urlFormat
 *
 * ```
 * '@<scope>/<registry>'
 * '@<scope>/<registry>@<version>'
 * ```
 *
 * @example
 * ```ts
 * import { defineConfig } from "jsrepo/config";
 * import { jsrepo } from "jsrepo/providers";
 *
 * export default defineConfig({
 * 	providers: [jsrepo()],
 * });
 * ```
 */
declare function jsrepo(options?: JsrepoOptions): ProviderFactory & {
  baseUrl: string;
};
//#endregion
//#region src/providers/index.d.ts
declare const DEFAULT_PROVIDERS: ProviderFactory[];
declare function fetchManifest(provider: Provider, options: FetchOptions): Promise<Result<Manifest, InvalidJSONError | ZodError | ManifestFetchError>>;
//#endregion
//#region src/utils/add.d.ts
type ResolvedRegistry = {
  url: string;
  provider: Provider;
  manifest: Manifest;
  token?: string;
};
/**
 * Resolves each registry url to it's manifest and provider so we can start fetching items.
 *
 * @param registries - An array of registry urls to resolve. i.e. ["github/ieedan/std", "gitlab/ieedan/std"]
 * @param options
 * @returns
 */
declare function resolveRegistries(registries: string[], {
  cwd,
  providers
}: {
  cwd: AbsolutePath;
  providers: ProviderFactory[];
}): Promise<Result<Map<string, ResolvedRegistry>, InvalidRegistryError | ManifestFetchError | InvalidJSONError | ZodError>>;
type WantedItem = {
  registryUrl?: string;
  itemName: string;
};
/**
 * Parses the wanted items and needed registries from an array of fully-qualified and or unqualified items.
 *
 * @remarks this only parses the items and does not actually resolve the items or registries
 *
 * @param items - An array of fully-qualified and or unqualified items. i.e. ["github/ieedan/std", "gitlab/ieedan/std", "math"]
 * @param options
 * @returns
 */
declare function parseWantedItems(items: string[], {
  providers,
  registries
}: {
  providers: ProviderFactory[];
  registries: string[];
}): Result<{
  wantedItems: WantedItem[];
  neededRegistries: string[];
}, RegistryNotProvidedError>;
type ResolvedWantedItem = {
  registry: ResolvedRegistry;
  item: {
    name: string;
    description: string | undefined;
    add: RegistryItemAdd | undefined;
    type: RegistryItemType;
    registryDependencies: string[] | undefined;
    dependencies: (RemoteDependency | string)[] | undefined;
    devDependencies: (RemoteDependency | string)[] | undefined;
    files: Array<RepositoryOutputFile | DistributedOutputManifestFile>;
    envVars: Record<string, string> | undefined;
    categories: string[] | undefined;
    meta: Record<string, string> | undefined;
  };
};
/**
 * Resolve the wanted items to the resolved registry. This will ask the user to select a registry if there are multiple matches to remove an ambiguity.
 * @remarks The only async "work" that should be done here is waiting for the user to respond
 * @param wantedItems
 * @param options
 */
declare function resolveWantedItems(wantedItems: WantedItem[], {
  resolvedRegistries,
  nonInteractive
}: {
  resolvedRegistries: Map<string, ResolvedRegistry>;
  nonInteractive: boolean;
}): Promise<Result<ResolvedWantedItem[], MultipleRegistriesError | RegistryItemNotFoundError>>;
type ResolvedItem$1 = {
  name: string;
  description: string | undefined;
  add: RegistryItemAdd | undefined;
  type: RegistryItemType;
  registryDependencies: string[] | undefined;
  dependencies: (RemoteDependency | string)[] | undefined;
  devDependencies: (RemoteDependency | string)[] | undefined;
  registry: ResolvedRegistry;
  files: Array<RepositoryOutputFile | DistributedOutputManifestFile>;
  envVars: Record<string, string> | undefined;
  categories: string[] | undefined;
  meta: Record<string, string> | undefined;
};
type ItemRepository = {
  name: string;
  type: RegistryItemType;
  add: RegistryItemAdd | undefined;
  description: string | undefined;
  dependencies: (RemoteDependency | string)[] | undefined;
  devDependencies: (RemoteDependency | string)[] | undefined;
  registry: ResolvedRegistry;
  files: Array<RepositoryOutputFile & {
    content: string;
  }>;
  envVars: Record<string, string> | undefined;
  categories: string[] | undefined;
  meta: Record<string, string> | undefined;
};
type ItemDistributed = DistributedOutputItem & {
  registry: ResolvedRegistry;
};
declare function fetchAllResolvedItems(items: ResolvedItem$1[]): Promise<Result<Array<ItemRepository | ItemDistributed>, RegistryItemFetchError | RegistryFileFetchError | InvalidJSONError>>;
type RegistryItemWithContent = ItemRepository | ItemDistributed;
declare function resolveAndFetchAllItems(wantedItems: ResolvedWantedItem[], {
  options
}: {
  options: {
    withExamples: boolean;
    withDocs: boolean;
    withTests: boolean;
  };
}): Promise<Result<Array<RegistryItemWithContent>, RegistryItemNotFoundError | RegistryItemFetchError | RegistryFileFetchError | InvalidJSONError>>;
/**
 * Recursively resolves the tree of wanted items and their dependencies.
 *
 * @param wantedItems - The wanted items to resolve.
 * @param options
 * @returns
 */
declare function resolveTree(wantedItems: ResolvedWantedItem[], {
  resolvedItems,
  options
}: {
  resolvedItems: Map<string, ResolvedItem$1>;
  options: {
    withExamples: boolean;
    withDocs: boolean;
    withTests: boolean;
  };
}): Result<ResolvedItem$1[], RegistryItemNotFoundError>;
declare function getPathsForItems({
  items,
  config,
  options,
  continueOnNoPath
}: {
  items: {
    name: string;
    type: RegistryItemType;
    files: {
      path: ItemRelativePath;
      type: RegistryItemType;
      target?: string;
    }[];
    registry: ResolvedRegistry;
  }[];
  config: Config | undefined;
  options: {
    cwd: AbsolutePath;
    yes: boolean;
  };
  continueOnNoPath?: boolean;
}): Promise<Result<{
  itemPaths: Record<string, {
    path: string;
    alias?: string;
  }>;
  resolvedPaths: Config['paths'];
  updatedPaths: Record<string, string>;
}, NoPathProvidedError>>;
type UpdatedFile = {
  itemName: string;
  registryUrl: string;
  _imports_: UnresolvedImport[];
  filePath: AbsolutePath;
  newPath: ItemRelativePath;
  originalPath: ItemRelativePath;
  content: string;
  fileType: RegistryItemType;
} & ({
  type: 'update';
  oldContent: string;
} | {
  type: 'create';
});
/**
 * Prepares updates for the items without applying them. This will transform the files and collect any dependencies and env vars needed.
 *
 * @param param0
 * @returns
 */
declare function prepareUpdates({
  items,
  itemPaths,
  configResult,
  options
}: {
  configResult: {
    path: string;
    config: Config;
  } | null;
  options: {
    cwd: AbsolutePath;
    yes: boolean;
    withExamples: boolean;
    withDocs: boolean;
    withTests: boolean;
  };
  itemPaths: Record<string, {
    path: string;
    alias?: string;
  }>;
  items: (ItemRepository | ItemDistributed)[];
}): Promise<Result<{
  neededDependencies: {
    dependencies: RemoteDependency[];
    devDependencies: RemoteDependency[];
  };
  neededEnvVars: Record<string, string> | undefined;
  neededFiles: UpdatedFile[];
}, InvalidDependencyError>>;
declare function updateFiles({
  files,
  options
}: {
  files: UpdatedFile[];
  options: {
    cwd: string;
    overwrite: boolean;
    expand: boolean;
    maxUnchanged: number;
  };
}): Promise<Result<string[], JsrepoError>>;
/**
 * Normalizes the item type for the path. We strip the `registry:` prefix if it exists.
 * @param type
 * @returns
 */
declare function normalizeItemTypeForPath(type: RegistryItemType): string;
//#endregion
//#region src/utils/path.d.ts
/**
 * Join all arguments together and normalize the resulting path.
 *
 * @param p
 * @param paths
 * @returns
 */
declare function joinAbsolute(p: AbsolutePath, ...paths: string[]): AbsolutePath;
//#endregion
//#region src/utils/prompts.d.ts
declare function promptAddEnvVars(neededEnvVars: Record<string, string>, {
  options
}: {
  options: {
    yes: boolean;
    cwd: AbsolutePath;
  };
}): Promise<Result<Record<string, string> | undefined, JsrepoError>>;
declare function promptInstallDependenciesByEcosystem(neededDependencies: {
  dependencies: RemoteDependency[];
  devDependencies: RemoteDependency[];
}, {
  options,
  config
}: {
  options: {
    cwd: AbsolutePath;
    yes: boolean;
  };
  config: Config | undefined;
}): Promise<{
  installed: boolean;
  dependencies: RemoteDependency[];
}>;
declare function detectPackageManager(cwd: AbsolutePath): Promise<Agent>;
//#endregion
//#region src/outputs/types.d.ts
interface Output {
  output(buildResult: BuildResult, opts: {
    cwd: AbsolutePath;
  }): Promise<void>;
  clean(opts: {
    cwd: AbsolutePath;
  }): Promise<void>;
}
//#endregion
//#region src/utils/utils.d.ts
type MaybeGetter<T, Args extends unknown[] = unknown[]> = T | ((...args: Args) => T);
type MaybeGetterAsync<T, Args extends unknown[] = unknown[]> = MaybeGetter<T, Args> | ((...args: Args) => Promise<T>);
//#endregion
//#region src/utils/config/index.d.ts
type RegistryConfigArgs = [{
  cwd: string;
}];
type Config = {
  /** An array of registries to fetch items from.
   * @example
   * ```ts
   * ["@ieedan/std", "@ieedan/shadcn-svelte-extras"]
   * ```
   */
  registries: string[];
  /** Define your registry or registries here. */
  registry: MaybeGetterAsync<RegistryConfig, RegistryConfigArgs> | MaybeGetterAsync<RegistryConfig, RegistryConfigArgs>[] | RegistryConfig | RegistryConfig[];
  providers: ProviderFactory[];
  /** Use this to add support for additional languages. */
  languages: Language[];
  transforms: Transform[];
  /**
   * Where to put items of a given type in your project. The key is the item type and the value is path where you want it to be added to your project.
   * You can use the '*' key to set a default path for all item types. Specify the path for a custom item with `<type>/<name>`.
   * @example
   * ```ts
   * import { defineConfig } from "jsrepo";
   *
   * export default defineConfig({
   *  // ...
   *  paths: {
   *    "*": "./src/items",
   *    ui: "./src/ui",
   *    "ui/button": "./components/ui",
   *  }
   * });
   * ```
   */
  paths: { [key in RegistryItemType | '*']?: string };
  /**
   * Custom warning handler. If not provided, warnings will be logged using the default logger.
   *
   * @example
   * ```ts
   * import { defineConfig } from "jsrepo";
   * import { InvalidImportWarning } from "jsrepo/warnings";
   *
   * export default defineConfig({
   *   // ...
   *   onwarn: (warning, handler) => {
   *     if (warning instanceof InvalidImportWarning) {
   *       // Skip warnings for $app/server and $app/navigation imports
   *       if (['$app/server', '$app/navigation'].includes(warning.specifier)) {
   *         return;
   *       }
   *     }
   *     handler(warning);
   *   }
   * });
   * ```
   */
  onwarn?: (warning: Warning, handler: (message: Warning) => void) => void;
};
type RegistryMeta = {
  /**
   * The name of the registry. When publishing to [jsrepo.com](https://jsrepo.com) the name must follow the format of `@<scope>/<name>`.
   */
  name: string;
  description?: string;
  /**
   * The version of the registry. When publishing to [jsrepo.com](https://jsrepo.com) the version can be provided as `package` to use the version from the `package.json` file, otherwise it should be a valid semver version.
   */
  version?: LooseAutocomplete<'package'>;
  homepage?: string;
  tags?: string[];
  repository?: string;
  bugs?: string;
  authors?: string[];
  meta?: Record<string, string>;
  /** The access level of the registry when published to jsrepo.com with `jsrepo publish`.
   *
   *  - "public" - The registry will be visible to everyone
   *  - "private" - The registry will be visible to only you
   *  - "marketplace" - The registry will purchasable on the jsrepo.com marketplace
   *
   *  @default "public"
   */
  access?: 'public' | 'private' | 'marketplace';
};
type RegistryConfig = RegistryMeta & {
  /** These dependencies will not be installed with registry items even if detected. */
  excludeDeps?: string[];
  items: RegistryItem[];
  /** An array of output strategies. These allow you to customize the way your registry is distributed. */
  outputs?: Output[];
  /** Plugins that users need to install to use your registry. (Will be installed automatically when initializing your registry)*/
  plugins?: {
    languages?: RegistryPlugin[];
    providers?: RegistryPlugin[];
    transforms?: RegistryPlugin[];
  };
  /** The default path for each item type. You can also provide the path for a specific item with `<type>/<name>`. */
  defaultPaths?: { [key in RegistryItemType]?: string };
};
type RegistryPlugin = {
  /** The name of the package */
  package: string;
  /** The version of the package */
  version?: string | undefined;
  /** Whether the plugin is optional. @default false */
  optional?: boolean;
};
type RegistryItemType = LooseAutocomplete<'block' | 'component' | 'lib' | 'hook' | 'ui' | 'page'>;
declare const RegistryItemAddOptions: readonly ["optionally-on-init", "on-init", "when-needed", "when-added"];
type RegistryItemAdd = (typeof RegistryItemAddOptions)[number];
type RegistryItem = {
  /** The name of the item. MUST be unique. Spaces are NOT allowed. */
  name: string;
  /** Human readable title of the item */
  title?: string;
  /** The type of the item. This can be any string. Users will configure their paths based on this type. */
  type: RegistryItemType;
  /** The description of the item not user visible but great for LLMs. */
  description?: string;
  /** Paths to the files that are required for the item to work. */
  files: RegistryItemFile[];
  /**
   * Requires that all dependencies of the item must be part of the registry.
   *
   * @default true
   */
  strict?: boolean;
  /** Whether the dependency resolution should be automatic or manual. @default "auto" */
  dependencyResolution?: 'auto' | 'manual';
  /**
   * Dependencies to other items in the registry. For many languages these can be automatically detected but can also be nice if there is another item you need that cannot be detected. They should be in the format of `<name>`.
   * @example
   * ```ts
   * {
   *  // ...
   *  registryDependencies: ["<name>"]
   * }
   * ```
   */
  registryDependencies?: string[];
  /**
   * Provide a list of dependencies to be installed with the item. If dependencies are provided as a string they will be assumed to be a js dependency.
   */
  dependencies?: (RemoteDependency | string)[];
  /**
   * Provide a list of devDependencies to be installed with the item. If dependencies are provided as a string they will be assumed to be a js dependency.
   */
  devDependencies?: (RemoteDependency | string)[];
  /**
   * Controls when the item will be added to the project.
   *
   * - "on-init" - Added on registry init or when it's needed by another item
   * - "when-needed" - Not listed and only added when another item is added that depends on it
   * - "when-added" - Added when the user selects it to be added
   *
   * @default "when-added"
   */
  add?: RegistryItemAdd;
  /**
   * Environment variables that are required for the item to work. These will be added to the users `.env` or `.env.local` file. NEVER ADD SECRETS HERE.
   */
  envVars?: Record<string, string>;
  categories?: string[];
  meta?: Record<string, string>;
};
declare const RegistryFileRoles: readonly ["example", "doc", "test", "file"];
type RegistryFileRoles = (typeof RegistryFileRoles)[number];
type RegistryItemFile = {
  /** Path of the file/folder relative to registry config. */
  path: string;
  /**
   * The type of the file. This will determine the path that the file will be added to in the users project.
   */
  type?: RegistryItemType;
  /**
   * The role of the file.
   *
   * - "file" - A regular file (always installed)
   * - "example" - An example file (optionally installed, great for LLMs)
   * - "test" - A test file (optionally installed)
   * - "doc" - A documentation file (optionally installed, great for LLMs)
   *
   * If a parent folder has a role this file will inherit the role from the parent folder.
   *
   * @default "file"
   */
  role?: RegistryFileRoles;
  /**
   * Whether the dependency resolution should be automatic or manual.
   * @default "auto"
   *
   * @remarks when this option is set on the parent registry item this option will have no effect
   */
  dependencyResolution?: 'auto' | 'manual';
  /**
   * The target path for this file in the users project. Overrides all other path settings.
   */
  target?: string;
  /**
   * Dependencies to other items in the registry. For many languages these can be automatically detected but can also be nice if there is another item you need that cannot be detected. They should be in the format of `<name>`.
   * @example
   * ```ts
   * {
   *  // ...
   *  registryDependencies: ["<name>"]
   * }
   * ```
   */
  registryDependencies?: string[];
  /**
   * Provide a list of dependencies to be installed with the item. If dependencies are provided as a string they will be assumed to be a js dependency.
   */
  dependencies?: (RemoteDependency | string)[];
  /**
   * Provide a list of devDependencies to be installed with the item. If dependencies are provided as a string they will be assumed to be a js dependency.
   */
  devDependencies?: (RemoteDependency | string)[];
  /**
   * Only valid as children of a folder. Allows you to individually configure each file in the folder.
   */
  files?: RegistryItemFolderFile[];
  /**
   * Include additional metadata on the item. (Available to LLMs when using the `@jsrepo/mcp` server)
   */
  meta?: Record<string, string>;
};
type RegistryItemFolderFile = Prettify<Omit<RegistryItemFile, 'target' | 'type' | 'path'> & {
  /**
   * Path to the file/folder relative to the parent folder.
   */
  path: string;
}>;
type TransformOptions = {
  cwd: AbsolutePath;
  registryUrl: string;
  item: {
    name: string;
    type: RegistryItemType;
  };
};
type Transform = {
  transform: (opts: {
    code: string;
    fileName: ItemRelativePath;
    options: TransformOptions;
  }) => Promise<{
    code?: string;
    fileName?: ItemRelativePath;
  }>;
};
declare function defineConfig(config: Partial<Config> | (() => Partial<Config>)): Config;
//#endregion
//#region src/utils/build.d.ts
type BuildResult = RegistryMeta & {
  plugins?: {
    languages?: RegistryPlugin[];
    providers?: RegistryPlugin[];
    transforms?: RegistryPlugin[];
  };
  items: ResolvedItem[];
  defaultPaths?: Record<string, string>;
};
type Ecosystem = LooseAutocomplete<'js'>;
type ResolvedItem = {
  name: string;
  title: string | undefined;
  type: RegistryItemType;
  description: string | undefined;
  files: RegistryFile[];
  /** Dependencies to other items in the registry */
  registryDependencies: string[] | undefined;
  /** Dependencies to code located in a remote repository to be installed later with a package manager. */
  dependencies: RemoteDependency[] | undefined;
  devDependencies: RemoteDependency[] | undefined;
  add: RegistryItemAdd;
  envVars: Record<string, string> | undefined;
  categories: string[] | undefined;
  meta: Record<string, string> | undefined;
};
type RegistryFile = {
  /** The absolute path to the file. This can be immediately used to read the file. */
  absolutePath: AbsolutePath;
  /** Path of the file relative to the parent item. */
  path: ItemRelativePath;
  content: string;
  type: RegistryItemType;
  role: RegistryFileRoles;
  /** Templates for resolving imports when adding items to users projects. This way users can add their items anywhere and things will just work. */
  _imports_: UnresolvedImport[];
  target?: string;
  registryDependencies: string[] | undefined;
  dependencies: RemoteDependency[] | undefined;
  devDependencies: RemoteDependency[] | undefined;
};
/** All the information that a client would need about the registry to correct imports in a users project. */
type UnresolvedImport = {
  /** The literal import string to be transformed on the client */
  import: string;
  item: string;
  file: {
    type: RegistryItemType;
    path: ItemRelativePath;
  };
  /** Additional properties to help resolve the import on the client */
  meta: Record<string, unknown>;
};
type RemoteDependency = {
  /** This helps us determine how to install the dependency later */
  ecosystem: Ecosystem;
  name: string;
  version?: string;
};
type LocalDependency = {
  /** The file name of the dependency. */
  fileName: AbsolutePath;
  /** The import string used to reference the dependency in the file. */
  import: string;
  /** A function that will resolve a template that can be used to transform the import on the client */
  createTemplate: (resolvedDependency: ResolvedFile) => Promise<Record<string, unknown>> | Record<string, unknown>;
};
type ParentItem = {
  name: string;
  type: RegistryItemType;
  registryName: string;
};
/**
 * A file that has not been resolved yet. This should not be a folder!
 */

type ResolvedFile = {
  /**
   * The absolute path to the file. This can be immediately used to read the file.
   */
  absolutePath: AbsolutePath;
  /**
   * Path of the file relative to the parent item.
   */
  path: ItemRelativePath;
  parent: ParentItem;
  type: RegistryItemType;
  role: RegistryFileRoles;
  dependencyResolution: 'auto' | 'manual';
  localDependencies: LocalDependency[];
  dependencies: RemoteDependency[];
  devDependencies: RemoteDependency[];
  manualDependencies: {
    registryDependencies: string[] | undefined;
    dependencies: RemoteDependency[];
    devDependencies: RemoteDependency[];
  };
  content: string;
  target: string | undefined;
};
//#endregion
//#region src/utils/config/utils.d.ts
/**
 * Searches for a a config file in the current directory (`jsrepo.config.(ts|js|mts|mjs)`)  it will search directories above the cwd until it finds a config file or reaches the user's home directory or root.
 *
 * @param cwd - The current working directory.
 * @param promptForContinueIfNull - Whether to prompt the user to continue if no config file is found.
 * @returns
 */
declare function loadConfigSearch({
  cwd,
  promptForContinueIfNull
}: {
  cwd: AbsolutePath;
  promptForContinueIfNull: boolean;
}): Promise<{
  config: Config;
  path: AbsolutePath;
} | null>;
//#endregion
export { ManifestSchema as $, svelte as $t, fetchManifest as A, MissingPeerDependencyError as At, _fs as B, NoRegistriesError as Bt, prepareUpdates as C, AbsolutePath as Cn, InvalidPluginError as Ct, resolveWantedItems as D, InvalidRegistryVersionError as Dt, resolveTree as E, InvalidRegistryNameError as Et, GitLabOptions as F, NoListedItemsError as Ft, CreateOptions as G, RegistryNotProvidedError as Gt, bitbucket as H, RegistryFileFetchError as Ht, gitlab as I, NoOutputsError as It, GetTokenWithRegistry as J, ZodError as Jt, FetchOptions as K, SelfReferenceError as Kt, GitHubOptions as L, NoPackageJsonFoundError as Lt, jsrepo as M, MultipleRegistriesError as Mt, HttpOptions as N, NoFilesError as Nt, updateFiles as O, JsrepoError as Ot, http as P, NoItemsToUpdateError as Pt, Manifest as Q, SvelteOptions as Qt, github as R, NoPathProvidedError as Rt, parseWantedItems as S, createWarningHandler as Sn, InvalidOptionsError as St, resolveRegistries as T, InvalidRegistryError as Tt, AzureOptions as U, RegistryItemFetchError as Ut, BitBucketOptions as V, ProviderFetchError as Vt, azure as W, RegistryItemNotFoundError as Wt, Provider as X, VueOptions as Xt, Prompts as Y, DEFAULT_LANGS as Yt, ProviderFactory as Z, vue as Zt, joinAbsolute as _, InvalidImportWarning as _n, IllegalItemNameError as _t, RegistryFileRoles as a, transformImports as an, distributed as at, getPathsForItems as b, Warning as bn, InvalidJSONError as bt, RegistryItemFile as c, CssOptions as cn, CLIError as ct, TransformOptions as d, InstallDependenciesOptions as dn, CouldNotFindJsrepoImportError as dt, JsOptions as en, RepositoryOutputManifest as et, defineConfig as f, Language as fn, DuplicateFileReferenceError as ft, promptInstallDependenciesByEcosystem as g, GlobPatternNoMatchWarning as gn, GlobError as gt, promptAddEnvVars as h, TransformImportsOptions as hn, FileNotFoundError as ht, RegistryConfig as i, resolveImports as in, DistributedOutputOptions as it, JsrepoOptions as j, ModuleNotFoundError as jt, DEFAULT_PROVIDERS as k, ManifestFetchError as kt, RegistryItemType as l, css as ln, ConfigNotFoundError as lt, detectPackageManager as m, ResolveDependenciesResult as mn, FailedToLoadConfigError as mt, RemoteDependency as n, installDependencies as nn, repository as nt, RegistryItem as o, HtmlOptions as on, AlreadyInitializedError as ot, Output as p, ResolveDependenciesOptions as pn, DuplicateItemNameError as pt, GetToken as q, Unreachable as qt, Config as r, js as rn, DistributedOutputManifest as rt, RegistryItemAdd as s, html as sn, BuildError as st, loadConfigSearch as t, getImports as tn, RepositoryOutputOptions as tt, Transform as u, ImportTransform as un, ConfigObjectNotFoundError as ut, RegistryItemWithContent as v, LanguageNotFoundWarning as vn, ImportedFileNotResolvedError as vt, resolveAndFetchAllItems as w, ItemRelativePath as wn, InvalidRegistryDependencyError as wt, normalizeItemTypeForPath as x, WarningHandler as xn, InvalidKeyTypeError as xt, fetchAllResolvedItems as y, UnresolvableDynamicImportWarning as yn, InvalidDependencyError as yt, FsOptions as z, NoProviderFoundError as zt };
//# sourceMappingURL=config-BgmoBEGw.d.mts.map